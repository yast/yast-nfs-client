{

module "Nfs::Options";
textdomain "nfs";

/**
 * Parse to an internal representation:
 * Simply split by commas, but "defaults" is represented by the empty list
 * @param options a fstab option string
 * @return list of individual options
 */
list<string> from_string(string options) {
    if (options == "defaults") { options = ""; }
    return splitstring (options, ",");
}

/**
 * Convert list of individual options to a fstab option string
 * @param option_list list of individual options
 * @return a fstab option string 
 */
string to_string(list<string> option_list) {
    string options = mergestring(option_list, ",");
    if (options == "") { options = "defaults"; }
    return options;
}

/**
 * Checks the nfs options for /etc/fstab:
 * nonempty, comma separated list of foo,nofoo,bar=baz (see nfs(5))
 * @param options   options
 * @return          a translated string with error message, emtpy string if ok
 */
global define string validate (string options) {
    // To translators: error popup
    if (size (options) == 0)   return _("Empty option strings are not allowed.");

    list<string> option_list = from_string(options);

    // The options should be kept synced with the code that handles them,
    // which is not an easy task, as there are many places:
    // - util-linux.rpm
    //   man 8 mount
    //   https://git.kernel.org/?p=utils/util-linux/util-linux.git;a=history;f=libmount/src/optmap.c
    // - nfs-client.rpm (nfs-utils.src.rpm)
    //   man 5 nfs
    //   http://git.linux-nfs.org/?p=steved/nfs-utils.git;a=history;f=utils/mount/nfsmount.c
    // - kernel: fs/nfs/super.c
    //   http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=history;f=fs/nfs/super.c
    // Note that minorversion in particular is mentioned only in the kernel
    // but not in nfs-utils. WTF.

    // these can be negated by "no"
    const list<string> NEGATABLE_OPTIONS   = [ "bg", "fg", "soft", "hard",
                    "intr", "posix", "cto", "ac", "acl",
    		    "lock", "tcp", "udp", "rdirplus",
    		    // these are common for all fs types
    		    "atime", "auto", "dev", "exec", "group", "owner",
    			    "suid", "user", "users"];
    const list<string> NEGATED_OPTIONS = maplist (string e, NEGATABLE_OPTIONS, ``(sformat ("no%1", e)));

    // these cannot be negated
    // they are not nfs specific BTW
    const list<string> SIMPLE_OPTIONS = ["defaults",
                   "async", "sync", "dirsync", "ro", "rw",
    		   "remount", "bind", "rbind", "_netdev", ];
    const list<string> OPTIONS_WITH_VALUE  = ["rsize", "wsize",
                    "timeo", "retrans", "acregmin", "acregmax",
    		    "acdirmin", "acdirmin", "acdirmax", "actimeo", "retry", "namlen",
    		    "port", "proto", "clientaddr", "mountport", "mounthost",
    		    "mountprog", "mountvers", "nfsprog", "nfsvers", "vers", "minorversion",
                        "sec" ];

    // first fiter out non value options and its nooptions forms (see nfs(5))
    option_list = filter (string e, option_list, ``(!contains (NEGATABLE_OPTIONS, e)));
    option_list = filter (string e, option_list, ``(!contains (NEGATED_OPTIONS, e)));
    option_list = filter (string e, option_list, ``(!contains (SIMPLE_OPTIONS, e)));

    string error_message = "";
    foreach (string opt, option_list,
    {
        list<string> opt_tuple = splitstring (opt, "=");
        string key   = opt_tuple[0]:"";
        string value = opt_tuple[1]:"";
        // By now we have filtered out known options without values;
        // so what is left is either unknown options, ...
        // FIXME: this also triggers for "intr=bogus"
        // because we should have considered '=' before the simple options
        // FIXME "'" + foo + "'" used not to break translations; merge it.
        if (!contains (OPTIONS_WITH_VALUE, key))
          // To translators: error popup
          error_message = sformat (_("Unknown option: %1"), "'" + key + "'");
        // ... or known ones with badly specified values
        else if (size (opt_tuple) != 2)
          // To translators: error popup
          error_message = sformat (_("Invalid option: %1"), "'" + opt + "'");
        else if (value == "")
          // To translators: error popup
          error_message = sformat (_("Empty value for option: %1"), "'" + key + "'");
        if (error_message != "")
          break;
    });

    return error_message;
}

/**
FIXME: factor out get_nfs4(vfstype, options) (depending on n::o)!
 * @param options fstab option string
 * @return is version >= 4.1 enabled
 */
global boolean get_nfs41(string options) {
    list<string> option_list = from_string(options);

    const string ENABLED = "minorversion=1";
    return contains(option_list, ENABLED);
}

/**
 * Add or remove minorversion=1 according to nfs41.
 * FIXME vfstype=nfs4 is deprecated in favor of nfsvers=4 (aka vers=4)
 * @param options fstab option string
 * @param nfs41   is version >= 4.1 enabled
 * @return        new fstab option string
 */
global define string set_nfs41(string options, boolean nfs41) {
    // don't mutate the string unnecessarily
    if (get_nfs41(options) == nfs41) {
        return options;
    }

    const string ENABLED  = "minorversion=1";
    const string DISABLED = "minorversion=0";

    list<string> option_list = from_string(options);
    option_list = filter(string opt, option_list, ``( opt != ENABLED ));
    option_list = filter(string opt, option_list, ``( opt != DISABLED ));

    if (nfs41) {
        option_list = add(option_list, ENABLED);
    }

    return to_string(option_list);
}

/*EOF*/
}
